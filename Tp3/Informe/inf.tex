\documentclass[spanish,12pt]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{xspace}
\usepackage{lmodern}
\usepackage{indentfirst}
\usepackage{xargs}
\usepackage{ifthen}
\usepackage{fancyhdr}
\usepackage{latexsym}
\usepackage{lastpage}
\usepackage{textcomp}
\usepackage{varwidth}
\usepackage{caratula, aed2-tad,aed2-symb,aed2-itef}
\usepackage{algorithmicx, algpseudocode, algorithm}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{float}
\usepackage{anysize}
\marginsize{1.5cm}{1.5cm}{1.5cm}{1.5cm}

\begin{document}

\titulo{Informe 3}
\materia{Algoritmos y Estructuras de Datos III}
\author{Grupo  \\Alvarez Vico Jazm\'in\\Cortés Conde Titó Javier María\\Pedraza Marcelo \\ Rozenberg Uriel Jonathan}

\integrante {Jazmín Alvazer Vico}{75/15}{jazminalvarezvico@gmail.com}
\integrante {Marcelo Pedraza}{393/14}{marcelopedraza314@gmail.com}
\integrante {Uriel Jonathan Rozenberg}{838/12}{rozenberguriel@gmail.com}
\integrante {Javier María Cortés Conde Titó}{252/15}{javiercortescondetito@gmail.com}

\maketitle


\clearpage

\tableofcontents
\cleardoublepage


\section{Introducción}
En nuestro problema Brian quiere convertirse en "maestro pokemon" en el menor tiempo posible. Para lograr este objetivo debe ir a todos los "gimnasios" y conquistarlos. Para poder hacerlo, cada gimnasio requiere una cantidad determinada de pociones. Estas pociones pueden obtenerse en las "pokeparadas". Las pokeparadas solo pueden visitarse una vez y de cada visita obtenemos tres pociones.

Formalmente, podemos caracterizar nuestras pokeparadas y  gimnasios como nodos formando un grafo completo, es decir que existen aristas para unir cualquier par de nodo. nuestras aristas deben tener peso, que equivalga a la distancia entre dos nodos. entonces queremos encontrar el camino mínimo que une todo los nodos gimnasios y los nodos pokeparada que hagan falta para poder conquistar todos los gimnasios. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Algoritmo exacto}

\subsection{Exlicación de la solución}

Para modelar este problema, creamos dos clases: Nodo y Mochila.
La clase Mochila contiene dos enteros $``capacidad"$ el cual corresponde con la capacidad de la entrada (k) y $``peso"$ en el cual se guarda la cantidad de pociones que se tiene en cada momento. 
en el Pseudocogigo se llaman a las funciones DameCapacidad y DamePeso, las mismas devuelven estos valores.

La clase Nodo tiene  un entero $``indice"$ como identificador de cada nodoy un entero $``pociones"$ en el cual se guardan las pociones que dan las pokeparadas o las que requieren los gimnasios(en este caso el valor es negativo). Ademas cuenta con un booleano para marcar si esta o no recorrido y dos enteros $``x"$ e $``y"$ para identificar las coordenadas del nodo.

Nuestra solución es utiliza la técnica de Backtracking para resolver el problema. Utilizamos variables globales (las cuales estan mencionadas en el pseudocodigo) ya que las utilizamos todo el tiempo en las funciones de nuestra resolución. De esta forma evitamos pasarlas cada vez como parametros de entrada.

Nuestro algoritmo de BT va formando recursivamente todas las soluciones posibles eligiendo gimnasios y pokeparas siempre que esto sea posible. El ciclo principal de la función va desde 0 hasta el Maximo entre el largo de los vectores de Nodos y pokeparadas. De esta forma vamos probando empezar con todos los nodos posibles. Cada vez que se elige un nodo para continuar se vuelve a llamar a la función BT para seguir construyendo la solución, luego se revierten los cambios para probar las demás soluciones. 

En nuestro algoritmo, cortamos una posible solución en el momento que supera la solución minima encontrada hasta el momento. De esta forma evitamos seguir ejecutando el algoritmo para una solución que claramente no va a ser la mejor, y así reducimos el tiempo de cómputo.

Mientras hacemos la lectura de datos, guardamos la cantidad máxima de pociones que requieren los gimnasios y el total de pociones que se requieren para ganar a todos los gimnasios. De esta forma si la capacidad de la mochila es menor al máximo de las pociones que piden los gimnasios o la cantidad de pociones que se pueden obtener (cantidad de pokeparadas multiplicado por tres) es menor a lo que se necesita para ganar a todos los gimnasios, entonces devolvemos -1 (evitando entrar en el backtracking) ya que el algoritmo no tiene solución. 


%falta cuandod devuelve -1 salvo esos 2 casos siempre hay solucion?%

\subsection{Pseudocodigo}

\begin{algorithm}[H]{\textbf{variables Globales}}
	\begin{algorithmic}[1]
		\State real MinActual 
		\State real MinGlobal
		\State vint RecorrifoGlobal
		\State vint RecorridoActual
		\State vnod PokeParadas
		\State vnod Gimnasios
		\State int PokeParadasRecorridas
		\State int PocionesNecesarias		
		\State Mochila Moch	
		\State entero GimRecorridos	
	
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{BT}()}
	\begin{algorithmic}[1]
		\State MinActual $\gets \infty$
		\State MinGlobal $\gets 0$
		\State Si  MinActual$>$MinGlobal  
			 \State \quad cortar
		\State finSi
		\State Si GimRecorridos = $|$Gimnasios$|$ 
		\State \quad Si MinActual $<$ Min Gobal
		\State \qquad MinGlobal $\gets$ MinActual
		\State \qquad RecorridoGlobal $\gets$ RecorridoAtual
		\State \quad finSi
		\State finSi
		\State Desde i=0 hasta i$<$Max($|$Gimnasios$|$,$|$PokeParadas$|$)
	
		\State \qquad Si i$< |$Gimnasios$|$
		\State \qquad \quad gim $\gets$ Gimnasios[i]
		\State \qquad \quad Si puedoIr(gim)
		\State \qquad \qquad Voy(gim)
 		\State \qquad finSi	
		\State \quad finSi
		\State \quad Si i $< |$PokeParadas$|$
		\State \quad pp $\gets$ Pokeparadas[i]
		\State \quad PokeParadasRecorridas $\gets$ PokeParadasRecorridas + 1 
		\State \qquad Si puedoIr(pp)
		\State \qquad Voy(pp) 	
		\State \qquad finSi
		\State \quad PokeParadasRecorridas $\gets$ PokeParadasRecorridas - 1 

		\State \quad finSi 
		\State finDesde
  		
		
		
		\State finSi
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{Voy}(Nodo n)}
	\begin{algorithmic}[1]
		\State Marco n
		\State Si RecorridoActual $ \not= \emptyset$
		\State \quad origen $\gets$ ultimo de RecorridoActual
		\State \quad minActual $\gets$ minActual+ Distancia(origen, p)
		\State finSi
		\State Agrego n a RecorridoActual
		\State Modifico el peso de moch segun las pociones n
		\State BT()
		\State revierto todas las modificaciones
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{puedoIrPP}(Nodo n){bool}}
	\begin{algorithmic}[1]
	\State NoConsumoDeMas $\gets$ Si al entrar a esta pokeparada se tiene que descartar pokebolas que no nos dejan ganar a todos los gimnasios asigno True, si no False.
	%terminar%
	\State  res $\gets$  moch no esta llena y n no esta recorrido y NoConsumoDeMas
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{PuedoIrGim}(Nodo n)}
	\begin{algorithmic}[1]
		\state res $\gets$  n no esta recorrido y DamePeso(moch) $\geq$ -(DamePosciones(n))
	\end{algorithmic}
\end{algorithm}


\subsection{Complejidad}

\subsection{Experimentación y análisis de resultados}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Heurística constructiva golosa}

El metodo de heurística goloza consiste en elegir siempre la mejor opción posible para continuar y formas la solución total. En este caso el criterio para elegir una mejor opción seria la cercanía.


\subsection{Exlicación de la solución}



\subsection{Pseudocodigo}

\begin{algorithm}[H]{\textbf{goloso}()}
	\begin{algorithmic}[1]
		\State Mientras Gimnasios $\not= \emptyset$
		\State \quad proxLugar=GimMasCercano
		\State \quad Si no puedo ir al gimnasio
		\State \qquad proxLugar=PokeParadaMasCercana
		\State \quad finSi
		\State \quad Si No puedo ir a ningun nodo 
		\State \qquad distanciaRecorrida=-1
		\State \qquad Recorrido = $\emptyset$
		\State \quad finSi
		\State \quad moverse(proxLugar)
		\State finMientras
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{moverse}(Nodo n)}
	\begin{algorithmic}[1]
		\State Modifico las mochilas según las pociones de n
		\State Agregar atras de Recorrido a n
		\State distanciaRecorrida + dist(n, posiciónActual)
		\State Actualizar posición actual
		\State Si n es gimnasio
		\State \quad sacar a n de Gimnasios
		\State Si No
		\State \quad sacar a n de pokeParadas
		\State finSi
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{ElegirPrimero}()}
	\begin{algorithmic}[1]
	\State Si existe un gimnasio que requiera requiera 0 pociones 
	\State \quad Agregar Atras a el nodo a Recorrido
	\State Si NO
	\State \quad Si existe un gimnasio que requiere menos de 4 pociones
	\State \qquad Elegir la pokeparada mas cercana y agregarla a Recorrido
	\State \quad Si No 
	\State \qquad elegir cualquier pokeparada para empezar
	\State \quad finSi
	\State finSi
	\end{algorithmic}
\end{algotihm}

\subsection{Complejidad}

\subsection{Experimentación y análisis de resultados}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Heurística de búsqueda local}

\subsection{Exlicación de la solución}

\subsection{Pseudocodigo}

\subsection{Complejidad}

\subsection{Experimentación y análisis de resultados}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Metaheurística}

Como metaheurística decidimos implementar un algoritmo ``GRASP$"$.
La técnica de este tipo de algoritmos consiste en combinar sucecivamente un algoritmo golozo randomizado para explorar nuevos espacios de soluciones y luego aplicar una busqueda local para mejorar cada solución. Al mismo tiempo se van comparando las soluciones y siempre se va eligiendo la mejor posible hasta que el algoritmo finaliza bajo algún criterio.

\subsection{Exlicación de la solución}

Utilizamos como criterio de terminación el tamaño del conjunto de ``entradas validas$"$. Este conjunto esta formado por Todos los gimnasios que pidan cero pociones para ser vencidos y todas las pokeparadas. Aplicamos el algoritmo golozo comenzando de cada uno de los nodos de este conjunto. 

El algoritmo golozo randomizado es una variación de nuestra heuristica goloza presentada en la sección (). % insertar seccion%
Para explorar el nuevo espacio de soluciones seleccionamos como candidatos al veinte porciento de los nodos por recorrer más cercanos a la posición actual.
Luego le asignamos una probabilidad a cada uno de ellos. La misma utiliza el siguiente criterio:

\begin{itemize}
	\item Si el nodo es gimnasio y tengo suficientes pociones en mi mochila para ir, +30
	\item Si el nodo es pokeparada y entran las 3 pociones en la mochila, +25
	\item Si el nodo es pokeparada y entran 2 pociones en la mochila, +15
	\item Si el nodo es pokeparada y entra solo 1 pocion en la mochila, +10
	\item Se le suma a cada nodo  bajo criterio de cercania 10*$\# $MasCercanos - 10* i donde i representa la posición en ese orden.
\end{itemize} 

Guardamos el valor de la sumatoria de los valores asignados a cada nodo  y creamos un número aleatorio entre 1 y este valor. El nodo elegido será el nodo con valor mayor más proximo al número aleatorio. Estas acciones se realizan en la función que llamamos en el pseudocodigo ``ElegirProximo$"$. 

Finalmente aplicamos la función de busqueda local de la sección ().


\subsection{Pseudocodigo}

\begin{algorithm}[H]{\textbf{GRASP}(vnod entradasValidas)}
	\begin{algorithmic}[1]
		\State solu = $\infty$
		\State Desde i=0 hasta $|$entradasValidas$|$
		\State \quad GolozoRand(entradasValidas[i])
		\State \quad Blocas(RecorridoGlobal, MinGlobal)
		\State \quad Si MinGlobal$<$solu
		\State \qquad solu=MinGlobal
		\State \qquad RecorridoSolu=RecorridoGlobal
		\State \quad finSi
		\State fin Desde
		
	\end{algorithmic}
\end{algorithm}


\subsection{Complejidad}

\subsection{Experimentación y análisis de resultados}
\end{document}
